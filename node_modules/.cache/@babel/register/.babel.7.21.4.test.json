{"{\"assumptions\":{},\"sourceRoot\":\"/home/tselger-7050/Desktop/fcc/routes/\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/home/tselger-7050/Desktop/fcc\",\"filename\":\"/home/tselger-7050/Desktop/fcc/routes/api.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"test\",\"root\":\"/home/tselger-7050/Desktop/fcc\",\"rootMode\":\"root\",\"plugins\":[],\"presets\":[]}:7.21.4:test":{"value":{"code":"'use strict';\n\nconst SudokuSolver = require('../controllers/sudoku-solver.js');\nmodule.exports = function (app) {\n  // Get the sudoku solver.\n  let solver = new SudokuSolver();\n  app.route('/api/check').post((req, res) => {\n    // Inputs.\n    let puzzle = req.body.puzzle;\n    let coord = req.body.coordinate;\n    let val = req.body.value;\n\n    // Check input fields exist.\n    if (puzzle == undefined | coord == undefined | val == undefined) return res.json({\n      \"error\": \"Required field(s) missing\"\n    });\n\n    // Test the inputs are valid.\n    let reCoord = /^([A-Ia-i])([1-9])$/;\n    let reVal = /^[1-9]$/;\n    let rePuz = /[^1-9\\.]/;\n    if (!reCoord.test(coord)) return res.json({\n      \"error\": \"Invalid coordinate\"\n    });\n    if (!reVal.test(val)) return res.json({\n      \"error\": \"Invalid value\"\n    });\n    if (puzzle.length != 81) return res.json({\n      \"error\": \"Expected puzzle to be 81 characters long\"\n    });\n    if (rePuz.test(puzzle)) return res.json({\n      \"error\": \"Invalid characters in puzzle\"\n    });\n\n    // Get the coordinate representation of the row and column.\n    let [_, row, col] = coord.match(reCoord);\n\n    // Test the value is already in that coordinate of the puzzle.\n    if (solver.checkDuplicateValue(puzzle, row, col, val)) return res.json({\n      \"valid\": true\n    });\n\n    // Determine if the value violates the row, column, and region sudoku rules.\n    let validRow = solver.checkRowPlacement(puzzle, row, col, val);\n    let validCol = solver.checkColPlacement(puzzle, row, col, val);\n    let validReg = solver.checkRegionPlacement(puzzle, row, col, val);\n    if (validRow & validCol & validReg) return res.json({\n      \"valid\": true\n    });\n\n    // Determine the conflicts (if they exist).\n    let conflict = [];\n    if (!validRow) conflict.push(\"row\");\n    if (!validCol) conflict.push(\"column\");\n    if (!validReg) conflict.push(\"region\");\n    return res.json({\n      \"valid\": false,\n      conflict\n    });\n  });\n  app.route('/api/solve').post((req, res) => {\n    // Inputs.\n    let puzzle = req.body.puzzle;\n\n    // Error if no puzzle is defined.\n    if (puzzle == undefined) return res.json({\n      error: 'Required field missing'\n    });\n\n    // Error if the puzzle has too many characters.\n    if (puzzle.length != 81) return res.json({\n      \"error\": \"Expected puzzle to be 81 characters long\"\n    });\n\n    // Error if the puzzle contains invalid characters.\n    let rePuz = /[^1-9\\.]/;\n    if (rePuz.test(puzzle)) return res.json({\n      \"error\": \"Invalid characters in puzzle\"\n    });\n\n    // Try to solve the puzzle.\n    let puzzleArr = [...puzzle];\n    // Error if it does not solve.\n    if (!solver.solve(puzzleArr)) return res.json({\n      \"error\": \"Puzzle cannot be solved\"\n    });\n    // Return the solution.\n    return res.json({\n      \"solution\": puzzleArr.join(\"\")\n    });\n  });\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJTdWRva3VTb2x2ZXIiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImFwcCIsInNvbHZlciIsInJvdXRlIiwicG9zdCIsInJlcSIsInJlcyIsInB1enpsZSIsImJvZHkiLCJjb29yZCIsImNvb3JkaW5hdGUiLCJ2YWwiLCJ2YWx1ZSIsInVuZGVmaW5lZCIsImpzb24iLCJyZUNvb3JkIiwicmVWYWwiLCJyZVB1eiIsInRlc3QiLCJsZW5ndGgiLCJfIiwicm93IiwiY29sIiwibWF0Y2giLCJjaGVja0R1cGxpY2F0ZVZhbHVlIiwidmFsaWRSb3ciLCJjaGVja1Jvd1BsYWNlbWVudCIsInZhbGlkQ29sIiwiY2hlY2tDb2xQbGFjZW1lbnQiLCJ2YWxpZFJlZyIsImNoZWNrUmVnaW9uUGxhY2VtZW50IiwiY29uZmxpY3QiLCJwdXNoIiwiZXJyb3IiLCJwdXp6bGVBcnIiLCJzb2x2ZSIsImpvaW4iXSwic291cmNlUm9vdCI6Ii9ob21lL3RzZWxnZXItNzA1MC9EZXNrdG9wL2ZjYy9yb3V0ZXMvIiwic291cmNlcyI6WyJhcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBTdWRva3VTb2x2ZXIgPSByZXF1aXJlKCcuLi9jb250cm9sbGVycy9zdWRva3Utc29sdmVyLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCkge1xuICBcbiAgLy8gR2V0IHRoZSBzdWRva3Ugc29sdmVyLlxuICBsZXQgc29sdmVyID0gbmV3IFN1ZG9rdVNvbHZlcigpO1xuXG4gIGFwcC5yb3V0ZSgnL2FwaS9jaGVjaycpXG4gICAgLnBvc3QoKHJlcSwgcmVzKSA9PiB7XG5cbiAgICAgIC8vIElucHV0cy5cbiAgICAgIGxldCBwdXp6bGUgPSByZXEuYm9keS5wdXp6bGU7XG4gICAgICBsZXQgY29vcmQgPSByZXEuYm9keS5jb29yZGluYXRlO1xuICAgICAgbGV0IHZhbCA9IHJlcS5ib2R5LnZhbHVlO1xuXG4gICAgICAvLyBDaGVjayBpbnB1dCBmaWVsZHMgZXhpc3QuXG4gICAgICBpZiAocHV6emxlPT11bmRlZmluZWQgfCBjb29yZD09dW5kZWZpbmVkIHwgdmFsPT11bmRlZmluZWQgKSByZXR1cm4gcmVzLmpzb24oeyBcImVycm9yXCI6IFwiUmVxdWlyZWQgZmllbGQocykgbWlzc2luZ1wiIH0pO1xuXG4gICAgICAvLyBUZXN0IHRoZSBpbnB1dHMgYXJlIHZhbGlkLlxuICAgICAgbGV0IHJlQ29vcmQgPSAvXihbQS1JYS1pXSkoWzEtOV0pJC87XG4gICAgICBsZXQgcmVWYWwgPSAvXlsxLTldJC87XG4gICAgICBsZXQgcmVQdXogPSAvW14xLTlcXC5dLztcbiAgICAgIGlmICghcmVDb29yZC50ZXN0KGNvb3JkKSkgcmV0dXJuIHJlcy5qc29uKHsgXCJlcnJvclwiOiBcIkludmFsaWQgY29vcmRpbmF0ZVwiIH0pO1xuICAgICAgaWYgKCFyZVZhbC50ZXN0KHZhbCkpIHJldHVybiByZXMuanNvbih7IFwiZXJyb3JcIjogXCJJbnZhbGlkIHZhbHVlXCIgfSk7XG4gICAgICBpZiAocHV6emxlLmxlbmd0aCAhPSA4MSkgcmV0dXJuIHJlcy5qc29uKHsgXCJlcnJvclwiOiBcIkV4cGVjdGVkIHB1enpsZSB0byBiZSA4MSBjaGFyYWN0ZXJzIGxvbmdcIiB9KTtcbiAgICAgIGlmIChyZVB1ei50ZXN0KHB1enpsZSkpIHJldHVybiByZXMuanNvbih7IFwiZXJyb3JcIjogXCJJbnZhbGlkIGNoYXJhY3RlcnMgaW4gcHV6emxlXCIgfSk7XG4gICAgICBcbiAgICAgIC8vIEdldCB0aGUgY29vcmRpbmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcm93IGFuZCBjb2x1bW4uXG4gICAgICBsZXQgW18sIHJvdywgY29sXSA9IGNvb3JkLm1hdGNoKHJlQ29vcmQpO1xuICAgICAgXG4gICAgICAvLyBUZXN0IHRoZSB2YWx1ZSBpcyBhbHJlYWR5IGluIHRoYXQgY29vcmRpbmF0ZSBvZiB0aGUgcHV6emxlLlxuICAgICAgaWYgKHNvbHZlci5jaGVja0R1cGxpY2F0ZVZhbHVlKHB1enpsZSxyb3cgLGNvbCwgdmFsKSkgcmV0dXJuIHJlcy5qc29uKHsgXCJ2YWxpZFwiOiB0cnVlIH0pO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHZhbHVlIHZpb2xhdGVzIHRoZSByb3csIGNvbHVtbiwgYW5kIHJlZ2lvbiBzdWRva3UgcnVsZXMuXG4gICAgICBsZXQgdmFsaWRSb3cgPSBzb2x2ZXIuY2hlY2tSb3dQbGFjZW1lbnQocHV6emxlLHJvdyAsY29sLCB2YWwpO1xuICAgICAgbGV0IHZhbGlkQ29sID0gc29sdmVyLmNoZWNrQ29sUGxhY2VtZW50KHB1enpsZSwgcm93LCBjb2wsIHZhbCk7XG4gICAgICBsZXQgdmFsaWRSZWcgPSBzb2x2ZXIuY2hlY2tSZWdpb25QbGFjZW1lbnQocHV6emxlLCByb3cgLGNvbCwgdmFsKTtcbiAgICAgIGlmICh2YWxpZFJvdyAmIHZhbGlkQ29sICYgdmFsaWRSZWcpIHJldHVybiByZXMuanNvbih7IFwidmFsaWRcIjogdHJ1ZSB9KTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSBjb25mbGljdHMgKGlmIHRoZXkgZXhpc3QpLlxuICAgICAgbGV0IGNvbmZsaWN0ID0gW107XG4gICAgICBpZiAoIXZhbGlkUm93KSBjb25mbGljdC5wdXNoKFwicm93XCIpO1xuICAgICAgaWYgKCF2YWxpZENvbCkgY29uZmxpY3QucHVzaChcImNvbHVtblwiKTtcbiAgICAgIGlmICghdmFsaWRSZWcpIGNvbmZsaWN0LnB1c2goXCJyZWdpb25cIik7XG5cbiAgICAgIHJldHVybiByZXMuanNvbih7IFwidmFsaWRcIjogZmFsc2UsIGNvbmZsaWN0IH0pO1xuICAgIH0pO1xuICAgIFxuICBhcHAucm91dGUoJy9hcGkvc29sdmUnKVxuICAgIC5wb3N0KChyZXEsIHJlcykgPT4ge1xuICAgICAgLy8gSW5wdXRzLlxuICAgICAgbGV0IHB1enpsZSA9IHJlcS5ib2R5LnB1enpsZTtcblxuICAgICAgLy8gRXJyb3IgaWYgbm8gcHV6emxlIGlzIGRlZmluZWQuXG4gICAgICBpZiAocHV6emxlID09IHVuZGVmaW5lZCkgcmV0dXJuIHJlcy5qc29uKHtlcnJvcjogJ1JlcXVpcmVkIGZpZWxkIG1pc3NpbmcnfSk7XG4gICAgICBcbiAgICAgIC8vIEVycm9yIGlmIHRoZSBwdXp6bGUgaGFzIHRvbyBtYW55IGNoYXJhY3RlcnMuXG4gICAgICBpZiAocHV6emxlLmxlbmd0aCAhPSA4MSkgcmV0dXJuIHJlcy5qc29uKHsgXCJlcnJvclwiOiBcIkV4cGVjdGVkIHB1enpsZSB0byBiZSA4MSBjaGFyYWN0ZXJzIGxvbmdcIiB9KTtcblxuICAgICAgLy8gRXJyb3IgaWYgdGhlIHB1enpsZSBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMuXG4gICAgICBsZXQgcmVQdXogPSAvW14xLTlcXC5dLztcbiAgICAgIGlmIChyZVB1ei50ZXN0KHB1enpsZSkpIHJldHVybiByZXMuanNvbih7IFwiZXJyb3JcIjogXCJJbnZhbGlkIGNoYXJhY3RlcnMgaW4gcHV6emxlXCIgfSk7XG5cbiAgICAgIC8vIFRyeSB0byBzb2x2ZSB0aGUgcHV6emxlLlxuICAgICAgbGV0IHB1enpsZUFyciA9IFsuLi5wdXp6bGVdO1xuICAgICAgLy8gRXJyb3IgaWYgaXQgZG9lcyBub3Qgc29sdmUuXG4gICAgICBpZiAoIXNvbHZlci5zb2x2ZShwdXp6bGVBcnIpKSByZXR1cm4gcmVzLmpzb24oeyBcImVycm9yXCI6IFwiUHV6emxlIGNhbm5vdCBiZSBzb2x2ZWRcIiB9KTtcbiAgICAgIC8vIFJldHVybiB0aGUgc29sdXRpb24uXG4gICAgICByZXR1cm4gcmVzLmpzb24oeyBcInNvbHV0aW9uXCI6ICBwdXp6bGVBcnIuam9pbihcIlwiKX0pO1xuICAgIH0pO1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWTs7QUFFWixNQUFNQSxZQUFZLEdBQUdDLE9BQU8sQ0FBQyxpQ0FBaUMsQ0FBQztBQUUvREMsTUFBTSxDQUFDQyxPQUFPLEdBQUcsVUFBVUMsR0FBRyxFQUFFO0VBRTlCO0VBQ0EsSUFBSUMs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","map":{"version":3,"names":["SudokuSolver","require","module","exports","app","solver","route","post","req","res","puzzle","body","coord","coordinate","val","value","undefined","json","reCoord","reVal","rePuz","test","length","_","row","col","match","checkDuplicateValue","validRow","checkRowPlacement","validCol","checkColPlacement","validReg","checkRegionPlacement","conflict","push","error","puzzleArr","solve","join"],"sourceRoot":"/home/tselger-7050/Desktop/fcc/routes/","sources":["api.js"],"sourcesContent":["'use strict';\n\nconst SudokuSolver = require('../controllers/sudoku-solver.js');\n\nmodule.exports = function (app) {\n  \n  // Get the sudoku solver.\n  let solver = new SudokuSolver();\n\n  app.route('/api/check')\n    .post((req, res) => {\n\n      // Inputs.\n      let puzzle = req.body.puzzle;\n      let coord = req.body.coordinate;\n      let val = req.body.value;\n\n      // Check input fields exist.\n      if (puzzle==undefined | coord==undefined | val==undefined ) return res.json({ \"error\": \"Required field(s) missing\" });\n\n      // Test the inputs are valid.\n      let reCoord = /^([A-Ia-i])([1-9])$/;\n      let reVal = /^[1-9]$/;\n      let rePuz = /[^1-9\\.]/;\n      if (!reCoord.test(coord)) return res.json({ \"error\": \"Invalid coordinate\" });\n      if (!reVal.test(val)) return res.json({ \"error\": \"Invalid value\" });\n      if (puzzle.length != 81) return res.json({ \"error\": \"Expected puzzle to be 81 characters long\" });\n      if (rePuz.test(puzzle)) return res.json({ \"error\": \"Invalid characters in puzzle\" });\n      \n      // Get the coordinate representation of the row and column.\n      let [_, row, col] = coord.match(reCoord);\n      \n      // Test the value is already in that coordinate of the puzzle.\n      if (solver.checkDuplicateValue(puzzle,row ,col, val)) return res.json({ \"valid\": true });\n\n      // Determine if the value violates the row, column, and region sudoku rules.\n      let validRow = solver.checkRowPlacement(puzzle,row ,col, val);\n      let validCol = solver.checkColPlacement(puzzle, row, col, val);\n      let validReg = solver.checkRegionPlacement(puzzle, row ,col, val);\n      if (validRow & validCol & validReg) return res.json({ \"valid\": true });\n\n      // Determine the conflicts (if they exist).\n      let conflict = [];\n      if (!validRow) conflict.push(\"row\");\n      if (!validCol) conflict.push(\"column\");\n      if (!validReg) conflict.push(\"region\");\n\n      return res.json({ \"valid\": false, conflict });\n    });\n    \n  app.route('/api/solve')\n    .post((req, res) => {\n      // Inputs.\n      let puzzle = req.body.puzzle;\n\n      // Error if no puzzle is defined.\n      if (puzzle == undefined) return res.json({error: 'Required field missing'});\n      \n      // Error if the puzzle has too many characters.\n      if (puzzle.length != 81) return res.json({ \"error\": \"Expected puzzle to be 81 characters long\" });\n\n      // Error if the puzzle contains invalid characters.\n      let rePuz = /[^1-9\\.]/;\n      if (rePuz.test(puzzle)) return res.json({ \"error\": \"Invalid characters in puzzle\" });\n\n      // Try to solve the puzzle.\n      let puzzleArr = [...puzzle];\n      // Error if it does not solve.\n      if (!solver.solve(puzzleArr)) return res.json({ \"error\": \"Puzzle cannot be solved\" });\n      // Return the solution.\n      return res.json({ \"solution\":  puzzleArr.join(\"\")});\n    });\n};\n"],"mappings":"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"}},"mtime":1631298864000},"{\"assumptions\":{},\"sourceRoot\":\"/home/tselger-7050/Desktop/fcc/controllers/\",\"caller\":{\"name\":\"@babel/register\"},\"cwd\":\"/home/tselger-7050/Desktop/fcc\",\"filename\":\"/home/tselger-7050/Desktop/fcc/controllers/sudoku-solver.js\",\"targets\":{},\"cloneInputAst\":true,\"babelrc\":false,\"configFile\":false,\"browserslistConfigFile\":false,\"passPerPreset\":false,\"envName\":\"test\",\"root\":\"/home/tselger-7050/Desktop/fcc\",\"rootMode\":\"root\",\"plugins\":[],\"presets\":[]}:7.21.4:test":{"value":{"code":"// Class that defines the related indexes for a cell index [0-80].\n// It can tell what the cells row indices, column indices, region indices, \n// adjacent rows indices (that are in the same region), adjacent \n// column indices (that are in the same region).\nclass Cell {\n  constructor(idx) {\n    //The index\n    this.idx = idx;\n\n    //The indices for the row that contain this cell.\n    let rowStart = Math.floor(idx / 9);\n    let incre = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    this.rowIdxs = incre.map(x => 9 * rowStart + x);\n\n    //The indices for the column that contain this cell.\n    let colStart = idx % 9;\n    this.colIdxs = incre.map(x => colStart + x * 9);\n\n    //The indices for the region that contain this cell.\n    let regStart = Math.floor(rowStart / 3) * 27 + Math.floor(colStart / 3) * 3;\n    this.regIdxs = incre.map(x => regStart + Math.floor(x / 3) * 9 + x % 3);\n\n    //The indices for the adjacent rows that are in this region.\n    let rowRegStart = 3 * Math.floor(rowStart / 3);\n    let next1Row = 9 * (rowRegStart + (rowStart + 1) % 3);\n    let next2Row = 9 * (rowRegStart + (rowStart + 2) % 3);\n    this.adjRegRowIdxs = [...incre.map(x => next1Row + x), ...incre.map(x => next2Row + x)];\n\n    //The indices for the adjacent columns that are in this region.\n    let colRegStart = 3 * Math.floor(colStart / 3);\n    let next1Col = colRegStart + (colStart + 1) % 3;\n    let next2Col = colRegStart + (colStart + 2) % 3;\n    this.adjRegColIdxs = [...incre.map(x => next1Col + x * 9), ...incre.map(x => next2Col + x * 9)];\n  }\n}\n\n// Class that generates all the cell values for all 80 cells.\nclass Indexer {\n  constructor() {\n    this.lookup = {};\n    for (let i = 0; i < 81; i++) {\n      this.lookup[i] = new Cell(i);\n    }\n  }\n}\n\n// Lookup for the row values to numbers [0-8].\nlet rowLookup = {\n  \"A\": 0,\n  \"B\": 1,\n  \"C\": 2,\n  \"D\": 3,\n  \"E\": 4,\n  \"F\": 5,\n  \"G\": 6,\n  \"H\": 7,\n  \"I\": 8,\n  \"a\": 0,\n  \"b\": 1,\n  \"c\": 2,\n  \"d\": 3,\n  \"e\": 4,\n  \"f\": 5,\n  \"g\": 6,\n  \"h\": 7,\n  \"i\": 8\n};\n\n// Lookup for the column values to numbers [0-8].\nlet colLookup = col => {\n  return col - 1;\n};\n\n// Maps the cell coordinates to a cell index [0-80].\nlet cellIdxMap = (row, col) => {\n  return 9 * rowLookup[row] + colLookup(col);\n};\n\n// Returns the substring of the puzzle that represents the rows.\nlet rowString = (puzzleString, cellIdx) => {\n  return indexer.lookup[cellIdx].rowIdxs.map(x => puzzleString[x]).join();\n};\n\n// Returns the substring of the puzzle that represents the columns.\nlet colString = (puzzleString, cellIdx) => {\n  return indexer.lookup[cellIdx].colIdxs.map(x => puzzleString[x]).join();\n};\n\n// Returns the substring of the puzzle that represents the region.\nlet regionString = (puzzleString, cellIdx) => {\n  return indexer.lookup[cellIdx].regIdxs.map(x => puzzleString[x]).join();\n};\n\n// Define the indexer to use in the Sudoku Solver.\nlet indexer = new Indexer();\n\n// Define the Sudoku solver.\nclass SudokuSolver {\n  // Checks if a puzzle's current inputs do not violate the rules of sudoku.\n  validate(puzzle) {\n    for (let cellIdx = 0; cellIdx < 80; cellIdx++) {\n      // If the cell has an entry.\n      if (puzzle[cellIdx] != \".\") {\n        // Get the value of the cell.\n        let k = puzzle[cellIdx];\n        // Create a trail puzzle and remove the current cell value.\n        let trailPuzzle = puzzle;\n        trailPuzzle[cellIdx] = \".\";\n        // Make a string of the puzzle.\n        let pString = trailPuzzle.join(\"\");\n        // Get the row.\n        let rString = rowString(pString, cellIdx);\n        // Get the column.\n        let cString = colString(pString, cellIdx);\n        // Get the region.\n        let reString = regionString(pString, cellIdx);\n        // Create the test regex from the cell value.\n        let re = new RegExp(k, \"g\");\n        // If the regex matches the current cell conflicts with the rules of sudoku.\n        if (re.test(rString + cString + reString)) {\n          return false;\n        }\n      }\n    }\n    // All cells passed.\n    return true;\n  }\n\n  // Checks the coordinate contains a duplicate value.\n  checkDuplicateValue(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row, column);\n    return puzzleString[cellIdx] == value;\n  }\n  // Check proposed value does not violate the sudoku row rule.\n  checkRowPlacement(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row, column);\n    // Get the puzzle substring that represents the cell's row.\n    let rString = rowString(puzzleString, cellIdx);\n    // Regex to check for the value in the row.\n    let re = new RegExp(value, \"g\");\n    return !re.test(rString);\n  }\n  // Check proposed value does not violate the sudoku column rule.\n  checkColPlacement(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row, column);\n    // Get the puzzle substring that represents the cell's column.\n    let cString = colString(puzzleString, cellIdx);\n    // Regex to check for the value in the column.\n    let re = new RegExp(value, \"g\");\n    return !re.test(cString);\n  }\n  // Check proposed value does not violate the sudoku region rule.\n  checkRegionPlacement(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row, column);\n    // Get the puzzle substring that represents the cell's region.\n    let reString = regionString(puzzleString, cellIdx);\n    // Regex to check for the value in the region.\n    let re = new RegExp(value, \"g\");\n    return !re.test(reString);\n  }\n  // Finds the values for a cell that do not violate the row, column and region rules of sudoku. Takes the coordinate.\n  findAllCellOptions(puzzleString, row, column) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row, column);\n    return this.findAllCellOptionsByCellInd(puzzleString, cellIdx);\n  }\n\n  //Finds the values for a cell that do not violate the row, column and region rules of sudoku. Takes the cell index.\n  findAllCellOptionsByCellInd(puzzleString, cellIdx) {\n    // Get the puzzle substring that represents the cell's row.\n    let rString = rowString(puzzleString, cellIdx);\n    // Get the puzzle substring that represents the cell's column.\n    let cString = colString(puzzleString, cellIdx);\n    // Get the puzzle substring that represents the cell's region.\n    let reString = regionString(puzzleString, cellIdx);\n    // Regex of all the characters not in the rows, columns and regions.\n    let re = new RegExp(\"[^\" + rString + cString + reString + \"]\", \"g\");\n    // Match with all possible values [1-9] and returns an array of the missing entries.\n    return \"123456789\".match(re);\n  }\n\n  // A brute force algorithm.\n  solve(puzzle) {\n    // Loop over the indices.\n    for (let cellIdx = 0; cellIdx < 81; cellIdx++) {\n      // If the puzzles cell is not set.\n      if (puzzle[cellIdx] == \".\") {\n        // Make the puzzle a string for matching.\n        let pString = puzzle.join(\"\");\n        // Loop over all the possible cell options.\n        for (let k = 1; k < 10; k++) {\n          // Get the puzzle substring that represents the cell's row.\n          let rString = rowString(pString, cellIdx);\n          // Get the puzzle substring that represents the cell's column.\n          let cString = colString(pString, cellIdx);\n          // Get the puzzle substring that represents the cell's region.\n          let reString = regionString(pString, cellIdx);\n          // Test the guessed value to see if it violates the row, column and region rules of sudoku.\n          let re = new RegExp(k, \"g\");\n          if (!re.test(rString + cString + reString)) {\n            // Set the puzzle value.\n            puzzle[cellIdx] = k;\n            // Now solve the new puzzle.\n            if (this.solve(puzzle)) {\n              // Signals the sub puzzles found the solution.\n              return true;\n            }\n          }\n          puzzle[cellIdx] = \".\";\n        }\n        // If all possible guesses for this cell (along with its sub puzzles) did not work, return false.\n        return false;\n      }\n    }\n    // Signals the sub puzzles found the solution.\n    return true;\n  }\n}\nmodule.exports = SudokuSolver;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJDZWxsIiwiY29uc3RydWN0b3IiLCJpZHgiLCJyb3dTdGFydCIsIk1hdGgiLCJmbG9vciIsImluY3JlIiwicm93SWR4cyIsIm1hcCIsIngiLCJjb2xTdGFydCIsImNvbElkeHMiLCJyZWdTdGFydCIsInJlZ0lkeHMiLCJyb3dSZWdTdGFydCIsIm5leHQxUm93IiwibmV4dDJSb3ciLCJhZGpSZWdSb3dJZHhzIiwiY29sUmVnU3RhcnQiLCJuZXh0MUNvbCIsIm5leHQyQ29sIiwiYWRqUmVnQ29sSWR4cyIsIkluZGV4ZXIiLCJsb29rdXAiLCJpIiwicm93TG9va3VwIiwiY29sTG9va3VwIiwiY29sIiwiY2VsbElkeE1hcCIsInJvdyIsInJvd1N0cmluZyIsInB1enpsZVN0cmluZyIsImNlbGxJZHgiLCJpbmRleGVyIiwiam9pbiIsImNvbFN0cmluZyIsInJlZ2lvblN0cmluZyIsIlN1ZG9rdVNvbHZlciIsInZhbGlkYXRlIiwicHV6emxlIiwiayIsInRyYWlsUHV6emxlIiwicFN0cmluZyIsInJTdHJpbmciLCJjU3RyaW5nIiwicmVTdHJpbmciLCJyZSIsIlJlZ0V4cCIsInRlc3QiLCJjaGVja0R1cGxpY2F0ZVZhbHVlIiwiY29sdW1uIiwidmFsdWUiLCJjaGVja1Jvd1BsYWNlbWVudCIsImNoZWNrQ29sUGxhY2VtZW50IiwiY2hlY2tSZWdpb25QbGFjZW1lbnQiLCJmaW5kQWxsQ2VsbE9wdGlvbnMiLCJmaW5kQWxsQ2VsbE9wdGlvbnNCeUNlbGxJbmQiLCJtYXRjaCIsInNvbHZlIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiL2hvbWUvdHNlbGdlci03MDUwL0Rlc2t0b3AvZmNjL2NvbnRyb2xsZXJzLyIsInNvdXJjZXMiOlsic3Vkb2t1LXNvbHZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8vIENsYXNzIHRoYXQgZGVmaW5lcyB0aGUgcmVsYXRlZCBpbmRleGVzIGZvciBhIGNlbGwgaW5kZXggWzAtODBdLlxuLy8gSXQgY2FuIHRlbGwgd2hhdCB0aGUgY2VsbHMgcm93IGluZGljZXMsIGNvbHVtbiBpbmRpY2VzLCByZWdpb24gaW5kaWNlcywgXG4vLyBhZGphY2VudCByb3dzIGluZGljZXMgKHRoYXQgYXJlIGluIHRoZSBzYW1lIHJlZ2lvbiksIGFkamFjZW50IFxuLy8gY29sdW1uIGluZGljZXMgKHRoYXQgYXJlIGluIHRoZSBzYW1lIHJlZ2lvbikuXG5jbGFzcyBDZWxsIHtcbiAgY29uc3RydWN0b3IoaWR4KSB7XG4gICAgLy9UaGUgaW5kZXhcbiAgICB0aGlzLmlkeCA9IGlkeDtcblxuICAgIC8vVGhlIGluZGljZXMgZm9yIHRoZSByb3cgdGhhdCBjb250YWluIHRoaXMgY2VsbC5cbiAgICBsZXQgcm93U3RhcnQgPSBNYXRoLmZsb29yKGlkeC85KTtcbiAgICBsZXQgaW5jcmUgPSBbMCwxLDIsMyw0LDUsNiw3LDhdO1xuICAgIHRoaXMucm93SWR4cyA9IGluY3JlLm1hcCh4ID0+IDkqcm93U3RhcnQreCk7XG5cbiAgICAvL1RoZSBpbmRpY2VzIGZvciB0aGUgY29sdW1uIHRoYXQgY29udGFpbiB0aGlzIGNlbGwuXG4gICAgbGV0IGNvbFN0YXJ0ID0gaWR4JTk7XG4gICAgdGhpcy5jb2xJZHhzID0gaW5jcmUubWFwKHggPT4gY29sU3RhcnQreCo5KTtcblxuICAgIC8vVGhlIGluZGljZXMgZm9yIHRoZSByZWdpb24gdGhhdCBjb250YWluIHRoaXMgY2VsbC5cbiAgICBsZXQgcmVnU3RhcnQgPSBNYXRoLmZsb29yKHJvd1N0YXJ0LzMpKjI3ICsgTWF0aC5mbG9vcihjb2xTdGFydC8zKSozO1xuICAgIHRoaXMucmVnSWR4cyA9IGluY3JlLm1hcCh4ID0+IHJlZ1N0YXJ0K01hdGguZmxvb3IoeC8zKSo5ICsgeCUzKTtcblxuICAgIC8vVGhlIGluZGljZXMgZm9yIHRoZSBhZGphY2VudCByb3dzIHRoYXQgYXJlIGluIHRoaXMgcmVnaW9uLlxuICAgIGxldCByb3dSZWdTdGFydCA9IDMqTWF0aC5mbG9vcihyb3dTdGFydC8zKTtcbiAgICBsZXQgbmV4dDFSb3cgPSA5Kihyb3dSZWdTdGFydCArIChyb3dTdGFydCsxKSUzKTtcbiAgICBsZXQgbmV4dDJSb3cgPSA5Kihyb3dSZWdTdGFydCArIChyb3dTdGFydCsyKSUzKTtcbiAgICB0aGlzLmFkalJlZ1Jvd0lkeHMgPSBbLi4uaW5jcmUubWFwKHggPT4gbmV4dDFSb3creCkgLCAuLi5pbmNyZS5tYXAoeCA9PiBuZXh0MlJvdyt4KV07XG5cbiAgICAvL1RoZSBpbmRpY2VzIGZvciB0aGUgYWRqYWNlbnQgY29sdW1ucyB0aGF0IGFyZSBpbiB0aGlzIHJlZ2lvbi5cbiAgICBsZXQgY29sUmVnU3RhcnQgPSAzKk1hdGguZmxvb3IoY29sU3RhcnQvMyk7XG4gICAgbGV0IG5leHQxQ29sID0gY29sUmVnU3RhcnQgKyAoY29sU3RhcnQrMSklMztcbiAgICBsZXQgbmV4dDJDb2wgPSBjb2xSZWdTdGFydCArIChjb2xTdGFydCsyKSUzO1xuICAgIHRoaXMuYWRqUmVnQ29sSWR4cyA9IFsuLi5pbmNyZS5tYXAoeCA9PiBuZXh0MUNvbCt4KjkpICwgLi4uaW5jcmUubWFwKHggPT4gbmV4dDJDb2wreCo5KV07XG4gIH1cbn1cblxuLy8gQ2xhc3MgdGhhdCBnZW5lcmF0ZXMgYWxsIHRoZSBjZWxsIHZhbHVlcyBmb3IgYWxsIDgwIGNlbGxzLlxuY2xhc3MgSW5kZXhlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubG9va3VwID0ge307XG4gICAgZm9yIChsZXQgaT0wOyBpPDgxOyBpKyspIHtcbiAgICAgICB0aGlzLmxvb2t1cFtpXSA9IG5ldyBDZWxsKGkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBMb29rdXAgZm9yIHRoZSByb3cgdmFsdWVzIHRvIG51bWJlcnMgWzAtOF0uXG5sZXQgcm93TG9va3VwID0ge1xuICBcIkFcIjowLCBcIkJcIjoxLCBcIkNcIjoyLCBcbiAgXCJEXCI6MywgXCJFXCI6NCwgXCJGXCI6NSwgXG4gIFwiR1wiOjYsIFwiSFwiOjcsIFwiSVwiOjgsXG4gIFwiYVwiOjAsIFwiYlwiOjEsIFwiY1wiOjIsXG4gIFwiZFwiOjMsIFwiZVwiOjQsIFwiZlwiOjUsIFxuICBcImdcIjo2LCBcImhcIjo3LCBcImlcIjo4XG59XG5cbi8vIExvb2t1cCBmb3IgdGhlIGNvbHVtbiB2YWx1ZXMgdG8gbnVtYmVycyBbMC04XS5cbmxldCBjb2xMb29rdXAgPSAoY29sKSA9PiB7cmV0dXJuIGNvbC0xfVxuXG4vLyBNYXBzIHRoZSBjZWxsIGNvb3JkaW5hdGVzIHRvIGEgY2VsbCBpbmRleCBbMC04MF0uXG5sZXQgY2VsbElkeE1hcCA9IChyb3csIGNvbCkgPT4ge1xuICByZXR1cm4gOSpyb3dMb29rdXBbcm93XSArIGNvbExvb2t1cChjb2wpXG59XG5cbi8vIFJldHVybnMgdGhlIHN1YnN0cmluZyBvZiB0aGUgcHV6emxlIHRoYXQgcmVwcmVzZW50cyB0aGUgcm93cy5cbmxldCByb3dTdHJpbmcgPSAocHV6emxlU3RyaW5nLCBjZWxsSWR4KSA9PiB7XG4gIHJldHVybiBpbmRleGVyLmxvb2t1cFtjZWxsSWR4XS5yb3dJZHhzLm1hcCh4PT5wdXp6bGVTdHJpbmdbeF0pLmpvaW4oKTtcbn1cblxuLy8gUmV0dXJucyB0aGUgc3Vic3RyaW5nIG9mIHRoZSBwdXp6bGUgdGhhdCByZXByZXNlbnRzIHRoZSBjb2x1bW5zLlxubGV0IGNvbFN0cmluZyA9IChwdXp6bGVTdHJpbmcsIGNlbGxJZHgpID0+IHtcbiAgcmV0dXJuIGluZGV4ZXIubG9va3VwW2NlbGxJZHhdLmNvbElkeHMubWFwKHg9PnB1enpsZVN0cmluZ1t4XSkuam9pbigpO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzdWJzdHJpbmcgb2YgdGhlIHB1enpsZSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlZ2lvbi5cbmxldCByZWdpb25TdHJpbmcgPSAocHV6emxlU3RyaW5nLCBjZWxsSWR4KSA9PiB7XG4gIHJldHVybiBpbmRleGVyLmxvb2t1cFtjZWxsSWR4XS5yZWdJZHhzLm1hcCh4PT5wdXp6bGVTdHJpbmdbeF0pLmpvaW4oKTtcbn1cblxuLy8gRGVmaW5lIHRoZSBpbmRleGVyIHRvIHVzZSBpbiB0aGUgU3Vkb2t1IFNvbHZlci5cbmxldCBpbmRleGVyID0gbmV3IEluZGV4ZXIoKTtcblxuLy8gRGVmaW5lIHRoZSBTdWRva3Ugc29sdmVyLlxuY2xhc3MgU3Vkb2t1U29sdmVyIHtcblxuICAvLyBDaGVja3MgaWYgYSBwdXp6bGUncyBjdXJyZW50IGlucHV0cyBkbyBub3QgdmlvbGF0ZSB0aGUgcnVsZXMgb2Ygc3Vkb2t1LlxuICB2YWxpZGF0ZShwdXp6bGUpIHtcbiAgICBmb3IgKGxldCBjZWxsSWR4PTA7IGNlbGxJZHg8ODA7IGNlbGxJZHgrKykge1xuICAgICAgLy8gSWYgdGhlIGNlbGwgaGFzIGFuIGVudHJ5LlxuICAgICAgaWYgKHB1enpsZVtjZWxsSWR4XSAhPSBcIi5cIikge1xuICAgICAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBjZWxsLlxuICAgICAgICBsZXQgayA9IHB1enpsZVtjZWxsSWR4XTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdHJhaWwgcHV6emxlIGFuZCByZW1vdmUgdGhlIGN1cnJlbnQgY2VsbCB2YWx1ZS5cbiAgICAgICAgbGV0IHRyYWlsUHV6emxlID0gcHV6emxlO1xuICAgICAgICB0cmFpbFB1enpsZVtjZWxsSWR4XSA9IFwiLlwiO1xuICAgICAgICAvLyBNYWtlIGEgc3RyaW5nIG9mIHRoZSBwdXp6bGUuXG4gICAgICAgIGxldCBwU3RyaW5nID0gdHJhaWxQdXp6bGUuam9pbihcIlwiKTtcbiAgICAgICAgLy8gR2V0IHRoZSByb3cuXG4gICAgICAgIGxldCByU3RyaW5nID0gcm93U3RyaW5nKHBTdHJpbmcsIGNlbGxJZHgpO1xuICAgICAgICAvLyBHZXQgdGhlIGNvbHVtbi5cbiAgICAgICAgbGV0IGNTdHJpbmcgPSBjb2xTdHJpbmcocFN0cmluZywgY2VsbElkeCk7XG4gICAgICAgIC8vIEdldCB0aGUgcmVnaW9uLlxuICAgICAgICBsZXQgcmVTdHJpbmcgPSByZWdpb25TdHJpbmcocFN0cmluZywgY2VsbElkeCk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgdGVzdCByZWdleCBmcm9tIHRoZSBjZWxsIHZhbHVlLlxuICAgICAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKGssIFwiZ1wiKTtcbiAgICAgICAgLy8gSWYgdGhlIHJlZ2V4IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2VsbCBjb25mbGljdHMgd2l0aCB0aGUgcnVsZXMgb2Ygc3Vkb2t1LlxuICAgICAgICBpZiAocmUudGVzdChyU3RyaW5nK2NTdHJpbmcrcmVTdHJpbmcpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFsbCBjZWxscyBwYXNzZWQuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBDaGVja3MgdGhlIGNvb3JkaW5hdGUgY29udGFpbnMgYSBkdXBsaWNhdGUgdmFsdWUuXG4gIGNoZWNrRHVwbGljYXRlVmFsdWUocHV6emxlU3RyaW5nLCByb3csIGNvbHVtbiwgdmFsdWUpIHtcbiAgICAvLyBNYXAgdGhlIGNvb3JkaW5hdGVzIHRvIHRoZSBjZWxsIGluZGV4LlxuICAgIGxldCBjZWxsSWR4ID0gY2VsbElkeE1hcChyb3csY29sdW1uKTtcbiAgICByZXR1cm4gcHV6emxlU3RyaW5nW2NlbGxJZHhdID09IHZhbHVlO1xuICB9XG4gIC8vIENoZWNrIHByb3Bvc2VkIHZhbHVlIGRvZXMgbm90IHZpb2xhdGUgdGhlIHN1ZG9rdSByb3cgcnVsZS5cbiAgY2hlY2tSb3dQbGFjZW1lbnQocHV6emxlU3RyaW5nLCByb3csIGNvbHVtbiwgdmFsdWUpIHtcbiAgICAvLyBNYXAgdGhlIGNvb3JkaW5hdGVzIHRvIHRoZSBjZWxsIGluZGV4LlxuICAgIGxldCBjZWxsSWR4ID0gY2VsbElkeE1hcChyb3csY29sdW1uKTtcbiAgICAvLyBHZXQgdGhlIHB1enpsZSBzdWJzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBjZWxsJ3Mgcm93LlxuICAgIGxldCByU3RyaW5nID0gcm93U3RyaW5nKHB1enpsZVN0cmluZywgY2VsbElkeCk7XG4gICAgLy8gUmVnZXggdG8gY2hlY2sgZm9yIHRoZSB2YWx1ZSBpbiB0aGUgcm93LlxuICAgIGxldCByZSA9IG5ldyBSZWdFeHAodmFsdWUsIFwiZ1wiKTtcbiAgICByZXR1cm4gIXJlLnRlc3QoclN0cmluZyk7XG4gIH1cbiAgLy8gQ2hlY2sgcHJvcG9zZWQgdmFsdWUgZG9lcyBub3QgdmlvbGF0ZSB0aGUgc3Vkb2t1IGNvbHVtbiBydWxlLlxuICBjaGVja0NvbFBsYWNlbWVudChwdXp6bGVTdHJpbmcsIHJvdywgY29sdW1uLCB2YWx1ZSkge1xuICAgIC8vIE1hcCB0aGUgY29vcmRpbmF0ZXMgdG8gdGhlIGNlbGwgaW5kZXguXG4gICAgbGV0IGNlbGxJZHggPSBjZWxsSWR4TWFwKHJvdyxjb2x1bW4pO1xuICAgIC8vIEdldCB0aGUgcHV6emxlIHN1YnN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGNlbGwncyBjb2x1bW4uXG4gICAgbGV0IGNTdHJpbmcgPSBjb2xTdHJpbmcocHV6emxlU3RyaW5nLCBjZWxsSWR4KTtcbiAgICAvLyBSZWdleCB0byBjaGVjayBmb3IgdGhlIHZhbHVlIGluIHRoZSBjb2x1bW4uXG4gICAgbGV0IHJlID0gbmV3IFJlZ0V4cCh2YWx1ZSwgXCJnXCIpO1xuICAgIHJldHVybiAhcmUudGVzdChjU3RyaW5nKTtcbiAgfVxuICAvLyBDaGVjayBwcm9wb3NlZCB2YWx1ZSBkb2VzIG5vdCB2aW9sYXRlIHRoZSBzdWRva3UgcmVnaW9uIHJ1bGUuXG4gIGNoZWNrUmVnaW9uUGxhY2VtZW50KHB1enpsZVN0cmluZywgcm93LCBjb2x1bW4sIHZhbHVlKSB7XG4gICAgLy8gTWFwIHRoZSBjb29yZGluYXRlcyB0byB0aGUgY2VsbCBpbmRleC5cbiAgICBsZXQgY2VsbElkeCA9IGNlbGxJZHhNYXAocm93LGNvbHVtbik7XG4gICAgLy8gR2V0IHRoZSBwdXp6bGUgc3Vic3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgY2VsbCdzIHJlZ2lvbi5cbiAgICBsZXQgcmVTdHJpbmcgPSByZWdpb25TdHJpbmcocHV6emxlU3RyaW5nLCBjZWxsSWR4KTtcbiAgICAvLyBSZWdleCB0byBjaGVjayBmb3IgdGhlIHZhbHVlIGluIHRoZSByZWdpb24uXG4gICAgbGV0IHJlID0gbmV3IFJlZ0V4cCh2YWx1ZSwgXCJnXCIpO1xuICAgIHJldHVybiAhcmUudGVzdChyZVN0cmluZyk7XG4gIH1cbiAgLy8gRmluZHMgdGhlIHZhbHVlcyBmb3IgYSBjZWxsIHRoYXQgZG8gbm90IHZpb2xhdGUgdGhlIHJvdywgY29sdW1uIGFuZCByZWdpb24gcnVsZXMgb2Ygc3Vkb2t1LiBUYWtlcyB0aGUgY29vcmRpbmF0ZS5cbiAgZmluZEFsbENlbGxPcHRpb25zKHB1enpsZVN0cmluZywgcm93LCBjb2x1bW4gKSB7XG4gICAgLy8gTWFwIHRoZSBjb29yZGluYXRlcyB0byB0aGUgY2VsbCBpbmRleC5cbiAgICBsZXQgY2VsbElkeCA9IGNlbGxJZHhNYXAocm93LGNvbHVtbik7XG4gICAgcmV0dXJuIHRoaXMuZmluZEFsbENlbGxPcHRpb25zQnlDZWxsSW5kKHB1enpsZVN0cmluZywgY2VsbElkeCk7XG4gIH1cblxuICAvL0ZpbmRzIHRoZSB2YWx1ZXMgZm9yIGEgY2VsbCB0aGF0IGRvIG5vdCB2aW9sYXRlIHRoZSByb3csIGNvbHVtbiBhbmQgcmVnaW9uIHJ1bGVzIG9mIHN1ZG9rdS4gVGFrZXMgdGhlIGNlbGwgaW5kZXguXG4gIGZpbmRBbGxDZWxsT3B0aW9uc0J5Q2VsbEluZChwdXp6bGVTdHJpbmcsIGNlbGxJZHgpIHtcbiAgICAvLyBHZXQgdGhlIHB1enpsZSBzdWJzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBjZWxsJ3Mgcm93LlxuICAgIGxldCByU3RyaW5nID0gcm93U3RyaW5nKHB1enpsZVN0cmluZywgY2VsbElkeCk7XG4gICAgLy8gR2V0IHRoZSBwdXp6bGUgc3Vic3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgY2VsbCdzIGNvbHVtbi5cbiAgICBsZXQgY1N0cmluZyA9IGNvbFN0cmluZyhwdXp6bGVTdHJpbmcsIGNlbGxJZHgpO1xuICAgIC8vIEdldCB0aGUgcHV6emxlIHN1YnN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGNlbGwncyByZWdpb24uXG4gICAgbGV0IHJlU3RyaW5nID0gcmVnaW9uU3RyaW5nKHB1enpsZVN0cmluZywgY2VsbElkeCk7XG4gICAgLy8gUmVnZXggb2YgYWxsIHRoZSBjaGFyYWN0ZXJzIG5vdCBpbiB0aGUgcm93cywgY29sdW1ucyBhbmQgcmVnaW9ucy5cbiAgICBsZXQgcmUgPSBuZXcgUmVnRXhwKFwiW15cIityU3RyaW5nK2NTdHJpbmcrcmVTdHJpbmcrXCJdXCIsIFwiZ1wiKTtcbiAgICAvLyBNYXRjaCB3aXRoIGFsbCBwb3NzaWJsZSB2YWx1ZXMgWzEtOV0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIG1pc3NpbmcgZW50cmllcy5cbiAgICByZXR1cm4gKFwiMTIzNDU2Nzg5XCIpLm1hdGNoKHJlKTtcbiAgfVxuXG4gIC8vIEEgYnJ1dGUgZm9yY2UgYWxnb3JpdGhtLlxuICBzb2x2ZShwdXp6bGUpIHtcbiAgICAvLyBMb29wIG92ZXIgdGhlIGluZGljZXMuXG4gICAgZm9yIChsZXQgY2VsbElkeD0wOyBjZWxsSWR4PDgxOyBjZWxsSWR4KysgKXtcbiAgICAgIC8vIElmIHRoZSBwdXp6bGVzIGNlbGwgaXMgbm90IHNldC5cbiAgICAgIGlmIChwdXp6bGVbY2VsbElkeF0gPT0gXCIuXCIpIHtcbiAgICAgICAgLy8gTWFrZSB0aGUgcHV6emxlIGEgc3RyaW5nIGZvciBtYXRjaGluZy5cbiAgICAgICAgbGV0IHBTdHJpbmcgPSBwdXp6bGUuam9pbihcIlwiKTtcbiAgICAgICAgLy8gTG9vcCBvdmVyIGFsbCB0aGUgcG9zc2libGUgY2VsbCBvcHRpb25zLlxuICAgICAgICBmb3IgKGxldCBrPTE7IGs8MTA7IGsrKyApe1xuICAgICAgICAgIC8vIEdldCB0aGUgcHV6emxlIHN1YnN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGNlbGwncyByb3cuXG4gICAgICAgICAgbGV0IHJTdHJpbmcgPSByb3dTdHJpbmcocFN0cmluZywgY2VsbElkeCk7XG4gICAgICAgICAgLy8gR2V0IHRoZSBwdXp6bGUgc3Vic3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGUgY2VsbCdzIGNvbHVtbi5cbiAgICAgICAgICBsZXQgY1N0cmluZyA9IGNvbFN0cmluZyhwU3RyaW5nLCBjZWxsSWR4KTtcbiAgICAgICAgICAvLyBHZXQgdGhlIHB1enpsZSBzdWJzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBjZWxsJ3MgcmVnaW9uLlxuICAgICAgICAgIGxldCByZVN0cmluZyA9IHJlZ2lvblN0cmluZyhwU3RyaW5nLCBjZWxsSWR4KTtcbiAgICAgICAgICAvLyBUZXN0IHRoZSBndWVzc2VkIHZhbHVlIHRvIHNlZSBpZiBpdCB2aW9sYXRlcyB0aGUgcm93LCBjb2x1bW4gYW5kIHJlZ2lvbiBydWxlcyBvZiBzdWRva3UuXG4gICAgICAgICAgbGV0IHJlID0gbmV3IFJlZ0V4cChrLCBcImdcIik7XG4gICAgICAgICAgaWYgKCFyZS50ZXN0KHJTdHJpbmcrY1N0cmluZytyZVN0cmluZykpIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgcHV6emxlIHZhbHVlLlxuICAgICAgICAgICAgcHV6emxlW2NlbGxJZHhdID0gaztcbiAgICAgICAgICAgIC8vIE5vdyBzb2x2ZSB0aGUgbmV3IHB1enpsZS5cbiAgICAgICAgICAgIGlmKHRoaXMuc29sdmUocHV6emxlKSkge1xuICAgICAgICAgICAgICAvLyBTaWduYWxzIHRoZSBzdWIgcHV6emxlcyBmb3VuZCB0aGUgc29sdXRpb24uXG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwdXp6bGVbY2VsbElkeF0gPSBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhbGwgcG9zc2libGUgZ3Vlc3NlcyBmb3IgdGhpcyBjZWxsIChhbG9uZyB3aXRoIGl0cyBzdWIgcHV6emxlcykgZGlkIG5vdCB3b3JrLCByZXR1cm4gZmFsc2UuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2lnbmFscyB0aGUgc3ViIHB1enpsZXMgZm91bmQgdGhlIHNvbHV0aW9uLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU3Vkb2t1U29sdmVyOyJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQSxJQUFJLENBQUM7RUFDVEMsV0FBV0EsQ0FBQ0MsR0FBRyxFQUFFO0lBQ2Y7SUFDQSxJQUFJLENBQUNBLEdBQUcsR0FBR0EsR0FBRzs7SUFFZDtJQUNBLElBQUlDLFFBQVEsR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUNILEdBQUcsR0FBQyxDQUFDLENBQUM7SUFDaEMsSUFBSUksS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLEVBQUMsQ0FBQyxFQUFDLENBQUMsRUFBQyxDQUFDLENBQUM7SUFDL0IsSUFBSSxDQUFDQyxPQUFPLEdBQUdELEtBQUssQ0FBQ0UsR0FBRyxDQUFDQyxDQUFDLElBQUksQ0FBQyxHQUFDTixRQUFRLEdBQUNNLENBQUMsQ0FBQzs7SUFFM0M7SUFDQSxJQUFJQyxRQUFRLEdBQUdSLEdBQUcsR0FBQyxDQUFDO0lBQ3BCLElBQUksQ0FBQ1MsT0FBTyxHQUFHTCxLQUFLLENBQUNFLEdBQUcsQ0FBQ0MsQ0FBQyxJQUFJQyxRQUFRLEdBQUNELENBQUMsR0FBQyxDQUFDLENBQUM7O0lBRTNDO0lBQ0EsSUFBSUcsUUFBUSxHQUFHUixJQUFJLENBQUNDLEtBQUssQ0FBQ0YsUUFBUSxHQUFDLENBQUMsQ0FBQyxHQUFDLEVBQUUsR0FBR0MsSUFBSSxDQUFDQyxLQUFLLENBQUNLLFFBQVEsR0FBQyxDQUFDLENBQUMsR0FBQyxDQUFDO0lBQ25FLElBQUksQ0FBQ0csT0FBTyxHQUFHUCxLQUFLLENB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","map":{"version":3,"names":["Cell","constructor","idx","rowStart","Math","floor","incre","rowIdxs","map","x","colStart","colIdxs","regStart","regIdxs","rowRegStart","next1Row","next2Row","adjRegRowIdxs","colRegStart","next1Col","next2Col","adjRegColIdxs","Indexer","lookup","i","rowLookup","colLookup","col","cellIdxMap","row","rowString","puzzleString","cellIdx","indexer","join","colString","regionString","SudokuSolver","validate","puzzle","k","trailPuzzle","pString","rString","cString","reString","re","RegExp","test","checkDuplicateValue","column","value","checkRowPlacement","checkColPlacement","checkRegionPlacement","findAllCellOptions","findAllCellOptionsByCellInd","match","solve","module","exports"],"sourceRoot":"/home/tselger-7050/Desktop/fcc/controllers/","sources":["sudoku-solver.js"],"sourcesContent":["\n// Class that defines the related indexes for a cell index [0-80].\n// It can tell what the cells row indices, column indices, region indices, \n// adjacent rows indices (that are in the same region), adjacent \n// column indices (that are in the same region).\nclass Cell {\n  constructor(idx) {\n    //The index\n    this.idx = idx;\n\n    //The indices for the row that contain this cell.\n    let rowStart = Math.floor(idx/9);\n    let incre = [0,1,2,3,4,5,6,7,8];\n    this.rowIdxs = incre.map(x => 9*rowStart+x);\n\n    //The indices for the column that contain this cell.\n    let colStart = idx%9;\n    this.colIdxs = incre.map(x => colStart+x*9);\n\n    //The indices for the region that contain this cell.\n    let regStart = Math.floor(rowStart/3)*27 + Math.floor(colStart/3)*3;\n    this.regIdxs = incre.map(x => regStart+Math.floor(x/3)*9 + x%3);\n\n    //The indices for the adjacent rows that are in this region.\n    let rowRegStart = 3*Math.floor(rowStart/3);\n    let next1Row = 9*(rowRegStart + (rowStart+1)%3);\n    let next2Row = 9*(rowRegStart + (rowStart+2)%3);\n    this.adjRegRowIdxs = [...incre.map(x => next1Row+x) , ...incre.map(x => next2Row+x)];\n\n    //The indices for the adjacent columns that are in this region.\n    let colRegStart = 3*Math.floor(colStart/3);\n    let next1Col = colRegStart + (colStart+1)%3;\n    let next2Col = colRegStart + (colStart+2)%3;\n    this.adjRegColIdxs = [...incre.map(x => next1Col+x*9) , ...incre.map(x => next2Col+x*9)];\n  }\n}\n\n// Class that generates all the cell values for all 80 cells.\nclass Indexer {\n  constructor() {\n    this.lookup = {};\n    for (let i=0; i<81; i++) {\n       this.lookup[i] = new Cell(i);\n    }\n  }\n}\n\n// Lookup for the row values to numbers [0-8].\nlet rowLookup = {\n  \"A\":0, \"B\":1, \"C\":2, \n  \"D\":3, \"E\":4, \"F\":5, \n  \"G\":6, \"H\":7, \"I\":8,\n  \"a\":0, \"b\":1, \"c\":2,\n  \"d\":3, \"e\":4, \"f\":5, \n  \"g\":6, \"h\":7, \"i\":8\n}\n\n// Lookup for the column values to numbers [0-8].\nlet colLookup = (col) => {return col-1}\n\n// Maps the cell coordinates to a cell index [0-80].\nlet cellIdxMap = (row, col) => {\n  return 9*rowLookup[row] + colLookup(col)\n}\n\n// Returns the substring of the puzzle that represents the rows.\nlet rowString = (puzzleString, cellIdx) => {\n  return indexer.lookup[cellIdx].rowIdxs.map(x=>puzzleString[x]).join();\n}\n\n// Returns the substring of the puzzle that represents the columns.\nlet colString = (puzzleString, cellIdx) => {\n  return indexer.lookup[cellIdx].colIdxs.map(x=>puzzleString[x]).join();\n}\n\n// Returns the substring of the puzzle that represents the region.\nlet regionString = (puzzleString, cellIdx) => {\n  return indexer.lookup[cellIdx].regIdxs.map(x=>puzzleString[x]).join();\n}\n\n// Define the indexer to use in the Sudoku Solver.\nlet indexer = new Indexer();\n\n// Define the Sudoku solver.\nclass SudokuSolver {\n\n  // Checks if a puzzle's current inputs do not violate the rules of sudoku.\n  validate(puzzle) {\n    for (let cellIdx=0; cellIdx<80; cellIdx++) {\n      // If the cell has an entry.\n      if (puzzle[cellIdx] != \".\") {\n        // Get the value of the cell.\n        let k = puzzle[cellIdx];\n        // Create a trail puzzle and remove the current cell value.\n        let trailPuzzle = puzzle;\n        trailPuzzle[cellIdx] = \".\";\n        // Make a string of the puzzle.\n        let pString = trailPuzzle.join(\"\");\n        // Get the row.\n        let rString = rowString(pString, cellIdx);\n        // Get the column.\n        let cString = colString(pString, cellIdx);\n        // Get the region.\n        let reString = regionString(pString, cellIdx);\n        // Create the test regex from the cell value.\n        let re = new RegExp(k, \"g\");\n        // If the regex matches the current cell conflicts with the rules of sudoku.\n        if (re.test(rString+cString+reString)) {\n          return false;\n        }\n      }\n    }\n    // All cells passed.\n    return true;\n  }\n\n  // Checks the coordinate contains a duplicate value.\n  checkDuplicateValue(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row,column);\n    return puzzleString[cellIdx] == value;\n  }\n  // Check proposed value does not violate the sudoku row rule.\n  checkRowPlacement(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row,column);\n    // Get the puzzle substring that represents the cell's row.\n    let rString = rowString(puzzleString, cellIdx);\n    // Regex to check for the value in the row.\n    let re = new RegExp(value, \"g\");\n    return !re.test(rString);\n  }\n  // Check proposed value does not violate the sudoku column rule.\n  checkColPlacement(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row,column);\n    // Get the puzzle substring that represents the cell's column.\n    let cString = colString(puzzleString, cellIdx);\n    // Regex to check for the value in the column.\n    let re = new RegExp(value, \"g\");\n    return !re.test(cString);\n  }\n  // Check proposed value does not violate the sudoku region rule.\n  checkRegionPlacement(puzzleString, row, column, value) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row,column);\n    // Get the puzzle substring that represents the cell's region.\n    let reString = regionString(puzzleString, cellIdx);\n    // Regex to check for the value in the region.\n    let re = new RegExp(value, \"g\");\n    return !re.test(reString);\n  }\n  // Finds the values for a cell that do not violate the row, column and region rules of sudoku. Takes the coordinate.\n  findAllCellOptions(puzzleString, row, column ) {\n    // Map the coordinates to the cell index.\n    let cellIdx = cellIdxMap(row,column);\n    return this.findAllCellOptionsByCellInd(puzzleString, cellIdx);\n  }\n\n  //Finds the values for a cell that do not violate the row, column and region rules of sudoku. Takes the cell index.\n  findAllCellOptionsByCellInd(puzzleString, cellIdx) {\n    // Get the puzzle substring that represents the cell's row.\n    let rString = rowString(puzzleString, cellIdx);\n    // Get the puzzle substring that represents the cell's column.\n    let cString = colString(puzzleString, cellIdx);\n    // Get the puzzle substring that represents the cell's region.\n    let reString = regionString(puzzleString, cellIdx);\n    // Regex of all the characters not in the rows, columns and regions.\n    let re = new RegExp(\"[^\"+rString+cString+reString+\"]\", \"g\");\n    // Match with all possible values [1-9] and returns an array of the missing entries.\n    return (\"123456789\").match(re);\n  }\n\n  // A brute force algorithm.\n  solve(puzzle) {\n    // Loop over the indices.\n    for (let cellIdx=0; cellIdx<81; cellIdx++ ){\n      // If the puzzles cell is not set.\n      if (puzzle[cellIdx] == \".\") {\n        // Make the puzzle a string for matching.\n        let pString = puzzle.join(\"\");\n        // Loop over all the possible cell options.\n        for (let k=1; k<10; k++ ){\n          // Get the puzzle substring that represents the cell's row.\n          let rString = rowString(pString, cellIdx);\n          // Get the puzzle substring that represents the cell's column.\n          let cString = colString(pString, cellIdx);\n          // Get the puzzle substring that represents the cell's region.\n          let reString = regionString(pString, cellIdx);\n          // Test the guessed value to see if it violates the row, column and region rules of sudoku.\n          let re = new RegExp(k, \"g\");\n          if (!re.test(rString+cString+reString)) {\n            // Set the puzzle value.\n            puzzle[cellIdx] = k;\n            // Now solve the new puzzle.\n            if(this.solve(puzzle)) {\n              // Signals the sub puzzles found the solution.\n              return true;\n            }\n          }\n          puzzle[cellIdx] = \".\";\n        }\n        // If all possible guesses for this cell (along with its sub puzzles) did not work, return false.\n        return false;\n      }\n    }\n    // Signals the sub puzzles found the solution.\n    return true;\n  }\n}\n\nmodule.exports = SudokuSolver;"],"mappings":"AACA;AACA;AACA;AACA;AACA,MAAMA,IAAI,CAAC;EACTC,WAAWA,CAACC,GAAG,EAAE;IACf;IACA,IAAI,CAACA,GAAG,GAAGA,GAAG;;IAEd;IACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACH,GAAG,GAAC,CAAC,CAAC;IAChC,IAAII,KAAK,GAAG,CAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,CAAC;IAC/B,IAAI,CAACC,OAAO,GAAGD,KAAK,CAACE,GAAG,CAACC,CAAC,IAAI,CAAC,GAACN,QAAQ,GAACM,CAAC,CAAC;;IAE3C;IACA,IAAIC,QAAQ,GAAGR,GAAG,GAAC,CAAC;IACpB,IAAI,CAACS,OAAO,GAAGL,KAAK,CAACE,GAAG,CAACC,CAAC,IAAIC,QAAQ,GAACD,CAAC,GAAC,CAAC,CAAC;;IAE3C;IACA,IAAIG,QAAQ,GAAGR,IAAI,CAACC,KAAK,CAACF,QAAQ,GAAC,CAAC,CAAC,GAAC,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACK,QAAQ,GAAC,CAAC,CAAC,GAAC,CAAC;IACnE,IAAI,CAACG,OAAO,GAAGP,KAAK,CAACE,GAAG,CAACC,CAAC,IAAIG,QAAQ,GAACR,IAAI,CAACC,KAAK,CAACI,CAAC,GAAC,CAAC,CAAC,GAAC,CAAC,GAAGA,CAAC,GAAC,CAAC,CAAC;;IAE/D;IACA,IAAIK,WAAW,GAAG,CAAC,GAACV,IAAI,CAACC,KAAK,CAACF,QAAQ,GAAC,CAAC,CAAC;IAC1C,IAAIY,QAAQ,GAAG,CAAC,IAAED,WAAW,GAAG,CAACX,QAAQ,GAAC,CAAC,IAAE,CAAC,CAAC;IAC/C,IAAIa,QAAQ,GAAG,CAAC,IAAEF,WAAW,GAAG,CAACX,QAAQ,GAAC,CAAC,IAAE,CAAC,CAAC;IAC/C,IAAI,CAACc,aAAa,GAAG,CAAC,GAAGX,KAAK,CAACE,GAAG,CAACC,CAAC,IAAIM,QAAQ,GAACN,CAAC,CAAC,EAAG,GAAGH,KAAK,CAACE,GAAG,CAACC,CAAC,IAAIO,QAAQ,GAACP,CAAC,CAAC,CAAC;;IAEpF;IACA,IAAIS,WAAW,GAAG,CAAC,GAACd,IAAI,CAACC,KAAK,CAACK,QAAQ,GAAC,CAAC,CAAC;IAC1C,IAAIS,QAAQ,GAAGD,WAAW,GAAG,CAACR,QAAQ,GAAC,CAAC,IAAE,CAAC;IAC3C,IAAIU,QAAQ,GAAGF,WAAW,GAAG,CAACR,QAAQ,GAAC,CAAC,IAAE,CAAC;IAC3C,IAAI,CAACW,aAAa,GAAG,CAAC,GAAGf,KAAK,CAACE,GAAG,CAACC,CAAC,IAAIU,QAAQ,GAACV,CAAC,GAAC,CAAC,CAAC,EAAG,GAAGH,KAAK,CAACE,GAAG,CAACC,CAAC,IAAIW,QAAQ,GAACX,CAAC,GAAC,CAAC,CAAC,CAAC;EAC1F;AACF;;AAEA;AACA,MAAMa,OAAO,CAAC;EACZrB,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACsB,MAAM,GAAG,CAAC,CAAC;IAChB,KAAK,IAAIC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC,EAAE,EAAEA,CAAC,EAAE,EAAE;MACtB,IAAI,CAACD,MAAM,CAACC,CAAC,CAAC,GAAG,IAAIxB,IAAI,CAACwB,CAAC,CAAC;IAC/B;EACF;AACF;;AAEA;AACA,IAAIC,SAAS,GAAG;EACd,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EACnB,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EACnB,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EACnB,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EACnB,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EACnB,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC,CAAC;EAAE,GAAG,EAAC;AACpB,CAAC;;AAED;AACA,IAAIC,SAAS,GAAIC,GAAG,IAAK;EAAC,OAAOA,GAAG,GAAC,CAAC;AAAA,CAAC;;AAEvC;AACA,IAAIC,UAAU,GAAGA,CAACC,GAAG,EAAEF,GAAG,KAAK;EAC7B,OAAO,CAAC,GAACF,SAAS,CAACI,GAAG,CAAC,GAAGH,SAAS,CAACC,GAAG,CAAC;AAC1C,CAAC;;AAED;AACA,IAAIG,SAAS,GAAGA,CAACC,YAAY,EAAEC,OAAO,KAAK;EACzC,OAAOC,OAAO,CAACV,MAAM,CAACS,OAAO,CAAC,CAACzB,OAAO,CAACC,GAAG,CAACC,CAAC,IAAEsB,YAAY,CAACtB,CAAC,CAAC,CAAC,CAACyB,IAAI,EAAE;AACvE,CAAC;;AAED;AACA,IAAIC,SAAS,GAAGA,CAACJ,YAAY,EAAEC,OAAO,KAAK;EACzC,OAAOC,OAAO,CAACV,MAAM,CAACS,OAAO,CAAC,CAACrB,OAAO,CAACH,GAAG,CAACC,CAAC,IAAEsB,YAAY,CAACtB,CAAC,CAAC,CAAC,CAACyB,IAAI,EAAE;AACvE,CAAC;;AAED;AACA,IAAIE,YAAY,GAAGA,CAACL,YAAY,EAAEC,OAAO,KAAK;EAC5C,OAAOC,OAAO,CAACV,MAAM,CAACS,OAAO,CAAC,CAACnB,OAAO,CAACL,GAAG,CAACC,CAAC,IAAEsB,YAAY,CAACtB,CAAC,CAAC,CAAC,CAACyB,IAAI,EAAE;AACvE,CAAC;;AAED;AACA,IAAID,OAAO,GAAG,IAAIX,OAAO,EAAE;;AAE3B;AACA,MAAMe,YAAY,CAAC;EAEjB;EACAC,QAAQA,CAACC,MAAM,EAAE;IACf,KAAK,IAAIP,OAAO,GAAC,CAAC,EAAEA,OAAO,GAAC,EAAE,EAAEA,OAAO,EAAE,EAAE;MACzC;MACA,IAAIO,MAAM,CAACP,OAAO,CAAC,IAAI,GAAG,EAAE;QAC1B;QACA,IAAIQ,CAAC,GAAGD,MAAM,CAACP,OAAO,CAAC;QACvB;QACA,IAAIS,WAAW,GAAGF,MAAM;QACxBE,WAAW,CAACT,OAAO,CAAC,GAAG,GAAG;QAC1B;QACA,IAAIU,OAAO,GAAGD,WAAW,CAACP,IAAI,CAAC,EAAE,CAAC;QAClC;QACA,IAAIS,OAAO,GAAGb,SAAS,CAACY,OAAO,EAAEV,OAAO,CAAC;QACzC;QACA,IAAIY,OAAO,GAAGT,SAAS,CAACO,OAAO,EAAEV,OAAO,CAAC;QACzC;QACA,IAAIa,QAAQ,GAAGT,YAAY,CAACM,OAAO,EAAEV,OAAO,CAAC;QAC7C;QACA,IAAIc,EAAE,GAAG,IAAIC,MAAM,CAACP,CAAC,EAAE,GAAG,CAAC;QAC3B;QACA,IAAIM,EAAE,CAACE,IAAI,CAACL,OAAO,GAACC,OAAO,GAACC,QAAQ,CAAC,EAAE;UACrC,OAAO,KAAK;QACd;MACF;IACF;IACA;IACA,OAAO,IAAI;EACb;;EAEA;EACAI,mBAAmBA,CAAClB,YAAY,EAAEF,GAAG,EAAEqB,MAAM,EAAEC,KAAK,EAAE;IACpD;IACA,IAAInB,OAAO,GAAGJ,UAAU,CAACC,GAAG,EAACqB,MAAM,CAAC;IACpC,OAAOnB,YAAY,CAACC,OAAO,CAAC,IAAImB,KAAK;EACvC;EACA;EACAC,iBAAiBA,CAACrB,YAAY,EAAEF,GAAG,EAAEqB,MAAM,EAAEC,KAAK,EAAE;IAClD;IACA,IAAInB,OAAO,GAAGJ,UAAU,CAACC,GAAG,EAACqB,MAAM,CAAC;IACpC;IACA,IAAIP,OAAO,GAAGb,SAAS,CAACC,YAAY,EAAEC,OAAO,CAAC;IAC9C;IACA,IAAIc,EAAE,GAAG,IAAIC,MAAM,CAACI,KAAK,EAAE,GAAG,CAAC;IAC/B,OAAO,CAACL,EAAE,CAACE,IAAI,CAACL,OAAO,CAAC;EAC1B;EACA;EACAU,iBAAiBA,CAACtB,YAAY,EAAEF,GAAG,EAAEqB,MAAM,EAAEC,KAAK,EAAE;IAClD;IACA,IAAInB,OAAO,GAAGJ,UAAU,CAACC,GAAG,EAACqB,MAAM,CAAC;IACpC;IACA,IAAIN,OAAO,GAAGT,SAAS,CAACJ,YAAY,EAAEC,OAAO,CAAC;IAC9C;IACA,IAAIc,EAAE,GAAG,IAAIC,MAAM,CAACI,KAAK,EAAE,GAAG,CAAC;IAC/B,OAAO,CAACL,EAAE,CAACE,IAAI,CAACJ,OAAO,CAAC;EAC1B;EACA;EACAU,oBAAoBA,CAACvB,YAAY,EAAEF,GAAG,EAAEqB,MAAM,EAAEC,KAAK,EAAE;IACrD;IACA,IAAInB,OAAO,GAAGJ,UAAU,CAACC,GAAG,EAACqB,MAAM,CAAC;IACpC;IACA,IAAIL,QAAQ,GAAGT,YAAY,CAACL,YAAY,EAAEC,OAAO,CAAC;IAClD;IACA,IAAIc,EAAE,GAAG,IAAIC,MAAM,CAACI,KAAK,EAAE,GAAG,CAAC;IAC/B,OAAO,CAACL,EAAE,CAACE,IAAI,CAACH,QAAQ,CAAC;EAC3B;EACA;EACAU,kBAAkBA,CAACxB,YAAY,EAAEF,GAAG,EAAEqB,MAAM,EAAG;IAC7C;IACA,IAAIlB,OAAO,GAAGJ,UAAU,CAACC,GAAG,EAACqB,MAAM,CAAC;IACpC,OAAO,IAAI,CAACM,2BAA2B,CAACzB,YAAY,EAAEC,OAAO,CAAC;EAChE;;EAEA;EACAwB,2BAA2BA,CAACzB,YAAY,EAAEC,OAAO,EAAE;IACjD;IACA,IAAIW,OAAO,GAAGb,SAAS,CAACC,YAAY,EAAEC,OAAO,CAAC;IAC9C;IACA,IAAIY,OAAO,GAAGT,SAAS,CAACJ,YAAY,EAAEC,OAAO,CAAC;IAC9C;IACA,IAAIa,QAAQ,GAAGT,YAAY,CAACL,YAAY,EAAEC,OAAO,CAAC;IAClD;IACA,IAAIc,EAAE,GAAG,IAAIC,MAAM,CAAC,IAAI,GAACJ,OAAO,GAACC,OAAO,GAACC,QAAQ,GAAC,GAAG,EAAE,GAAG,CAAC;IAC3D;IACA,OAAQ,WAAW,CAAEY,KAAK,CAACX,EAAE,CAAC;EAChC;;EAEA;EACAY,KAAKA,CAACnB,MAAM,EAAE;IACZ;IACA,KAAK,IAAIP,OAAO,GAAC,CAAC,EAAEA,OAAO,GAAC,EAAE,EAAEA,OAAO,EAAE,EAAE;MACzC;MACA,IAAIO,MAAM,CAACP,OAAO,CAAC,IAAI,GAAG,EAAE;QAC1B;QACA,IAAIU,OAAO,GAAGH,MAAM,CAACL,IAAI,CAAC,EAAE,CAAC;QAC7B;QACA,KAAK,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC,EAAE,EAAEA,CAAC,EAAE,EAAE;UACvB;UACA,IAAIG,OAAO,GAAGb,SAAS,CAACY,OAAO,EAAEV,OAAO,CAAC;UACzC;UACA,IAAIY,OAAO,GAAGT,SAAS,CAACO,OAAO,EAAEV,OAAO,CAAC;UACzC;UACA,IAAIa,QAAQ,GAAGT,YAAY,CAACM,OAAO,EAAEV,OAAO,CAAC;UAC7C;UACA,IAAIc,EAAE,GAAG,IAAIC,MAAM,CAACP,CAAC,EAAE,GAAG,CAAC;UAC3B,IAAI,CAACM,EAAE,CAACE,IAAI,CAACL,OAAO,GAACC,OAAO,GAACC,QAAQ,CAAC,EAAE;YACtC;YACAN,MAAM,CAACP,OAAO,CAAC,GAAGQ,CAAC;YACnB;YACA,IAAG,IAAI,CAACkB,KAAK,CAACnB,MAAM,CAAC,EAAE;cACrB;cACA,OAAO,IAAI;YACb;UACF;UACAA,MAAM,CAACP,OAAO,CAAC,GAAG,GAAG;QACvB;QACA;QACA,OAAO,KAAK;MACd;IACF;IACA;IACA,OAAO,IAAI;EACb;AACF;AAEA2B,MAAM,CAACC,OAAO,GAAGvB,YAAY"}},"mtime":1631298864000}}